// Function written by Nicolas Stifani nstifani@gmail.com for more info

// Defines Global Variables
requires("1.51n");
var PluginName="KinemaJ";
var MacroName="Track Markers";
var FileExt="TIF";
var MinNbFile=1;
var FolderSuffix="Tracked";
var SubDirArray=newArray("Tables","Labels","Cleaned","Parameters");
CellSeparator= "\t";
LineSeparator="\n";



//////////////////////////////////////////////// Header, Set Preferences, Options and Housekeeping
// Select All measurements, Invert Y, and use 9 decimals
run("Set Measurements...", "area mean standard modal min centroid center perimeter bounding fit shape feret's integrated median skewness kurtosis area_fraction stack display invert redirect=None decimal=9");
run("Line Width...", "line=1"); // Set Line width as 1
run("Input/Output...", "jpeg=100 gif=-1 file=.txt use copy_row save_column"); // Set Output as Txt and save columns and ignore row numbers
run("Point Tool...", "type=Hybrid color=yellow size=Large label show counter=0"); // Set the Point tool as yellow Medium Circle
run("Colors...", "foreground=white background=black selection=yellow"); // Set foreground and background colors Selection is yellow
run("Appearance...", "  menu=0 16-bit=Automatic"); // Change appareance of 16bit image as automatic
run("Misc...", "divide=Infinity"); // Make sure Miscellaneous Options are set correctly
run("Overlay Options...", "stroke=cyan width=2 point=Hybrid size=Large fill=none apply show"); // Overlay Options
run("Labels...", "color=White font=10 show bold"); // Labels options
call("ij.Prefs.set", "threshold.mode", 0); // Make the ImageJ preferences for threshold visualisation as Red over background

// Set IJ Size and position
IJPosX=screenWidth*0.1; // The position of ImageJ in X // Set IJ Size and position
IJPosY=screenHeight*0; // The position of ImageJ in Y at the top of the screen
IJSizeX=570; // The width of ImageJ toolbar in pixel
IJSizeY=100; // The Height of ImageJ toolbar in pixel
Spacer=25; // A spacer
DummyVariable=eval("script","IJ.getInstance().setLocation("+IJPosX+","+IJPosY+");"); // Adjust the position of the ImageJ toolbar

// Set Toolbar Size and position
ToolbarSizeX=250; // Set Toolbar Size and position
ToolbarSizeY=200; // Size of the toolbar
ToolbarPosX=IJPosX+IJSizeX+Spacer; // Position of the Toolbar is to the right of the ImageJ toolbar
ToolbarPosY=IJPosY; // Position of to the Toolbar in Y

// Position the Toolbar
if(isOpen(PluginName+" Toolbar")){selectWindow(PluginName+" Toolbar"); setLocation(ToolbarPosX,ToolbarPosY);}

// Set Threshold Window Size and Position
ThresholdSizeX=290;
ThresholdSizeY=260;
ThresholdPosX=ToolbarPosX; // The Position in X of the threshold window is below the toolbar
ThresholdPosY=ToolbarPosY+ToolbarSizeY+Spacer; // Threshold toolbar is just below the plugin toolbar
call("ij.Prefs.set", "threshold.loc", ThresholdPosX+" , "+ThresholdPosY); // Save in the preferences

// Set ROI Manager Size and Position
ROIManagerSizeX=250;
ROIManagerSizeY=300;
ROIManagerPosX=ToolbarPosX; // The Position in X of the ROI manager window
ROIManagerPosY=ToolbarPosY+ToolbarSizeY+Spacer+ThresholdSizeY+Spacer;
call("ij.Prefs.set", "manager.loc", ROIManagerPosX+" , "+ROIManagerPosY); // Save in the preferences

// Set Results Size and Position
ResultsSizeX=(screenWidth-(ToolbarPosX+ToolbarSizeX+Spacer));
ResultsSizeY=ROIManagerPosY-Spacer;
ResultsPosX=ToolbarPosX+ToolbarSizeX+Spacer;
ResultsPosY=ToolbarPosY;
call("ij.Prefs.set", "results.loc", ResultsPosX+" , "+ResultsPosY);  // Save in the preferences
call("ij.Prefs.set", "results.width", ResultsSizeX); // Save in the preferences
call("ij.Prefs.set", "results.height", ResultsSizeY); // Save in the preferences

// Set Log location
LogSizeX=(screenWidth-(ToolbarPosX+ToolbarSizeX+Spacer));
LogSizeY=ROIManagerPosY-Spacer;
LogPosX=ToolbarPosX+ToolbarSizeX+Spacer;
LogPosY=ToolbarPosY;
call("ij.Prefs.set", "log.loc", LogPosX+" , "+LogPosY); // Save in the preferences

// Set Debug location
DebugSizeX=(screenWidth-(ToolbarPosX+ToolbarSizeX+Spacer));
DebugSizeY= ROIManagerPosY-Spacer;
DebugPosX=ToolbarPosX+ToolbarSizeX+Spacer;
DebugPosY=ToolbarPosY;
call("ij.Prefs.set", "debug.loc", DebugPosX+" , "+DebugPosY); // Save in the preferences

// Set point Tool location
PointToolSizeX=250;
PointToolSizeY=300;
PointToolPosX= ToolbarPosX+ROIManagerSizeX+Spacer;
PointToolPosY= ToolbarPosY+ToolbarSizeY+Spacer+ThresholdSizeY+Spacer;

// Set Brightness and contrast location
BCSizeX=150;
BCSizeY=300;
BCPosX=PointToolPosX+PointToolSizeX+Spacer;
BCPosY=ROIManagerPosY;
call("ij.Prefs.set", "b&c.loc", BCPosX+" , "+BCPosY);  // Save in the preferences
//////////////////////////////////////////////// Header and Housekeeping




//////////////////////////////////////////////// General Functions
/////////////////////////// Function to Append to an array
function Append(ArrayI, Value) {
  ArrayJ = newArray(ArrayI.length+1);
  for (ValueI=0; ValueI<ArrayI.length; ValueI++)
  ArrayJ[ValueI] = ArrayI[ValueI];
  ArrayJ[ArrayI.length] = Value;
  return ArrayJ;
}
/////////////////////////// Function to Append to an array

/////////////////////////// Function to display a message
var MessageDialogPass;
function MessageDialog(Message){
  MessageDialogPass=0;
  ListUtilityWindows=newArray("Threshold", "Results", "ROI Manager", "B&C");
  CloseUtilityWindows(ListUtilityWindows);
  Dialog.create(PluginName+" Information");
  Dialog.setInsets(0,0,0);
  Dialog.addMessage(Message);
  Dialog.setLocation(ToolbarPosX, ToolbarPosY+ToolbarSizeY+2*Spacer);
  Dialog.show();
  MessageDialogPass=1;
}
/////////////////////////// Function to display a message

/////////////////////////// Function to display an error and propose to options
var ErrorDialogPass;
var UserResponseErrorDialog;
function ErrorDialog(MessageError, MessageFix, ErrorResponseArray){
  ErrorDialogPass=0;
  ListUtilityWindows=newArray("Threshold", "Results", "ROI Manager", "B&C");
  CloseUtilityWindows(ListUtilityWindows);
  Dialog.create(PluginName+" Information");
  Dialog.setInsets(0,0,0);
  Dialog.addMessage(MessageError);
  Dialog.setInsets(0,0,0);
  Dialog.addMessage(MessageFix);
  Dialog.setInsets(0,50,0);
  Dialog.addRadioButtonGroup("", ErrorResponseArray, ErrorResponseArray.length, 1, ErrorResponseArray[0]);
  Dialog.setLocation(ToolbarPosX, ToolbarPosY+ToolbarSizeY+2*Spacer);
  Dialog.show();
  UserResponseErrorDialog=Dialog.getRadioButton();
  return UserResponseErrorDialog;
}
/////////////////////////// Function to display an error and propose to options

/////////////////////////// Function to select an Input Directory
// containing at least MinNbFile with the correct file Extension FileExt
// This function also prevents from having files with more than one . in their filenames
var SelectInputDirPass; // Switch for the dialog box
var InputDirPath; // Path of the input directory
var ParentDir; // ParentDirectory of the selected input directory
var InputDirName; // Name of the Input Directory
var InputFileList;
var NbFile;

function SelectInputDir(MinNbFile, FileExt){
  // MinNbFile This is the minimum Nb of file to be present in the list to be accepted
  // FileExt This is the file extension as a string example "tif"
  InputDirPath=getDirectory("Select a folder containing at least "+MinNbFile+" "+FileExt+" file(s) to process."); // Select a folder
  InputItemList=getFileList(InputDirPath); // List of Item in the selected folder
  ParentDir=File.getParent(InputDirPath)+File.separator;
  InputDirName=File.getName(InputDirPath);

  SelectInputDirPass=0; // Switch for the Function
  InputFileList=newArray(0);
  UserResponseErrorDialog="";

  // Evaluate the Nb of file with correct extension and add them to InputCorrectExtFileList
  for (ItemI=0; ItemI<InputItemList.length; ItemI++){
    if(endsWith(toLowerCase(InputItemList[ItemI]), "."+toLowerCase(FileExt))){ // Select files with correct extension
      // If file has the correct extension check the BaseName
      BasenameFileIArray=split(InputItemList[ItemI],"."); // Make an array from the filename
      if(BasenameFileIArray.length!=2){ // if there is more than one . in the file name abort
        MessageError="Sorry but the "+FileExt+" file:\n\""+InputItemList[ItemI]+"\"\ncontains more than one \".\" in its filename.";
        MessageFix="The function \""+MacroName+"\" does NOT allow filenames with more than one unique \".\" used for the file extension.";
        ErrorResponseArray=newArray("Ignore This File", "Select Another Folder", "Cancel and Close");
        MessageQuit="The function \""+ MacroName+"\" stopped because the file:\n\""+InputItemList[ItemI]+"\"\ncontains more than one \".\"\nMake sure filenames have no more than one unique \".\" for the file extension.";
        UserResponseErrorDialog=ErrorDialog(MessageError, MessageFix, ErrorResponseArray);
        if(UserResponseErrorDialog==ErrorResponseArray[ErrorResponseArray.length-1]){
          CleanExit(MessageQuit);
        } else if (UserResponseErrorDialog=="Ignore This File"){
          // Ignore
        } else if (UserResponseErrorDialog=="Select Another Folder") {
          ItemI=InputItemList.length;
          SelectInputDirPass=0;
        }
      } else { // If basename is good add it to the InputFileList
        InputFileList=Append(InputFileList, InputItemList[ItemI]);
      }
    } // End of if fileExt is correct
  } // End of for ItemI

  // Make sure InpuFileList is > MinNbFile
  NbFile=InputFileList.length;
  if(InputFileList.length<MinNbFile && UserResponseErrorDialog!="Select Another Folder"){ // If the Nb of file with correct extension is not at least equal to the MinNbFile Create Error Message.
    MessageError="Sorry but the folder:\n\"" +InputDirName+"\"\ndoes not contain at least "+MinNbFile+" "+FileExt+" file(s).";
    MessageFix="The function \""+MacroName+"\" requires a folder that contains at least "+MinNbFile+" "+FileExt+" file(s).";
    ErrorResponseArray=newArray("Select Another Folder", "Cancel and Close");
    MessageQuit="The function \""+ MacroName+"\" stopped because the folder:\n\""+InputDirName+"\"\ndid not contain at least "+MinNbFile+" "+FileExt+" file(s).";
    UserResponseErrorDialog=ErrorDialog(MessageError, MessageFix, ErrorResponseArray);
    if(UserResponseErrorDialog==ErrorResponseArray[ErrorResponseArray.length-1]){
      CleanExit(MessageQuit);
    } else {
      SelectInputDirPass=0;
    }
  } else if (UserResponseErrorDialog=="Select Another Folder"){
    SelectInputDirPass=0; // InputDir Pass the criteria
  } else {
    SelectInputDirPass=1; // InputDir Pass the criteria
  }
}
/////////////////////////// Function to select an Input Directory

/////////////////////////// Function to create a new output directory
var OutputDirPath; // The path of the output directory
var OutputDirName; // The name of the output directory
function CreateOutputDir(ParentDir, InputDirName, FolderSuffix){ // Folder suffix is a string appended to the input Directory
  OutputDirPath=ParentDir+InputDirName+"_"+FolderSuffix+File.separator; // Create the outputdirpath
  n=1;
  while(File.exists(OutputDirPath)!=0){ // If the path already exist, increment with _ n until it does not exist
    n++;
    OutputDirPath=ParentDir+InputDirName+"_"+FolderSuffix+"_"+n+File.separator;
  } // End of making sure the outpudirectory is a new folder
  File.makeDirectory(OutputDirPath); // Create the outpudirectory
  OutputDirName=File.getName(OutputDirPath); // Get the Name of the output directory
}
/////////////////////////// Function to create a new output directory

/////////////////////////// Function to create subfolders within the newly create outputdirectory
function CreateOutputSubDir(SubDirArray) { // SubDirArray is an array of the desired subfolders
  for(i=0;i<SubDirArray.length;i++){
    SubDirPath=OutputDirPath+SubDirArray[i]+File.separator; // Because outpudirpath is unique and new the subfolders do not exist yet so no need to check if they are already present
    File.makeDirectory(SubDirPath);
  } // End of for
} // End of CreateOutputSubDir function
// NOTE:It is useful to create a string for the subdirectory paths
// For each element in the subdirarray addMessage
// Output[SubDirArrayElementN]Path=""+OutputDirPath+"[SubDirArrayElementN]"+file.separator;
// Then you can use directly the string to save within a subdirectory
/////////////////////////// Function to create subfolders within the newly create outputdirectory

/////////////////////////// Function Close and CleanUp Function
function CloseAndCleanUp(PluginName, FileI, NbFile, FileExt, InputDirName, OutputDirName){
  ListImages=getList("image.titles");
  for(n=0; n<ListImages.length; n++){ImageN=ListImages[n]; selectWindow(ImageN); run("Close");} // Close open Images
  ListUtilityWindows=newArray("Threshold", "Results", "ROI Manager", "B&C");
  CloseUtilityWindows(ListUtilityWindows);
  beep();
  // Closing Dialog Box
  Dialog.create(PluginName+" Information");
  Dialog.setInsets(0,0,0);
  Dialog.addMessage(FileI+" of "+ NbFile+" "+ FileExt+ " file(s) in the folder:\n\""+InputDirName+"\"\nhave been processed successfully.");
  Dialog.setInsets(0,0,0);
  Dialog.addMessage("Files are saved in the following folder:\n\""+OutputDirName+"\".");
  Dialog.setLocation(ToolbarPosX, ToolbarPosY+ToolbarSizeY+2*Spacer);
  Dialog.show();
}
/////////////////////////// Function Close and CleanUp Function

/////////////////////////// CleanExit Function
function CleanExit(MessageQuit){
  ListImages=getList("image.titles");
  for(n=0; n<ListImages.length; n++){ImageN=ListImages[n]; selectWindow(ImageN); run("Close");} // Close open Images
  ListUtilityWindows=newArray("Threshold", "Results", "ROI Manager", "B&C");
  CloseUtilityWindows(ListUtilityWindows);
  beep();
  Dialog.create(PluginName+" Information");
  Dialog.setInsets(0,0,0);
  Dialog.addMessage(MessageQuit);
  Dialog.setLocation(ToolbarPosX, ToolbarPosY+ToolbarSizeY+2*Spacer);
  Dialog.show();
  exit();
}
/////////////////////////// CleanExit Function

/////////////////////////// Close UtilityWindows
function CloseUtilityWindows(ListUtilityWindows){
  // Typically  ListUtilityWindows=newArray("Threshold", "Results", "ROI Manager", "B&C");
  for(WindowI=0; WindowI<ListUtilityWindows.length; WindowI++){
    UtilityWindowI=ListUtilityWindows[WindowI];
    if(isOpen(UtilityWindowI)){
      if(UtilityWindowI=="Results"){run("Clear Results");}
      if(UtilityWindowI=="ROI Manager"){roiManager("reset");}
      selectWindow(UtilityWindowI); run("Close"); }
    }
  }
  /////////////////////////// Close UtilityWindows
  //////////////////////////////////////////////// End of General Functions










  //////////////////////////////////////////////// Specific Functions
  /////////////////////////// SelectMasterDirectory
  // This function also prevents from having files with more than one . in their filenames
  var MasterInputDirPass=0; // Switch for the dialog box
  var MasterInputDirPath; // Path of the input directory
  var ParentDir; // ParentDirectory of the selected input directory
  var MasterInputDirName; // Name of the Input Directory
  //var NbFileWithCorrectExt; // Nb of File with the correct extension in the input directory
  //  var MasterInputItemList; // List of Files and folders in the input directory (all files no matter the extension)
  //  var InputCorrectExtFileList; // List of files with the correct extension
  var InputFileList;
  var NbFile;
  RequiredSubfolderArray=newArray("Cropped", "Thresholded");
  MinNbFile=1;
  FileExt="TIF";
  // Function to select a folder containing required subfolders each must contain minFile with the FileExt
  // Files should be present in both folders
  function SelectMasterInputDir(RequiredSubfolderArray, MinNbFile, FileExt){
    // Prompt to select the folder
    MasterInputDirPath=getDirectory("Select the folder containing the required subfolder(s)."); // Select a Folder
    MasterInputList=getFileList(MasterInputDirPath);
    ParentDir=File.getParent(MasterInputDirPath)+File.separator;
    MasterInputDirName=File.getName(MasterInputDirPath);

    // Check for proper Subfolders
    SubfolderPass=0;
    for (ItemI=0; ItemI<RequiredSubfolderArray.length; ItemI++){ // Screen the RequiredItem List
      for (ItemN=0; ItemN<MasterInputList.length; ItemN++){
        if(RequiredSubfolderArray[ItemI]+File.separator==MasterInputList[ItemN]){
          SubfolderPass++;
          ItemN=MasterInputList.length; // End the loop once found
        } // end of if found increment
      } // end of for item N
      // If required subfolders is not found
      if(SubfolderPass!=ItemI+1){
        MessageError="Sorry but the folder:\n\"" +MasterInputDirName+"\"\ndoes not contain the following required subfolder:\n- \""+RequiredSubfolderArray[ItemI]+"\"";
        MessageFix="The function \""+MacroName+"\" requires a folder containing the following subfolders:";
        for (n=0;n<RequiredSubfolderArray.length;n++){
          MessageFix=MessageFix+"\n- \""+RequiredSubfolderArray[n]+"\"";
        }
        ErrorResponseArray=newArray("Select Another Folder", "Cancel and Close");
        MessageQuit="The function \""+ MacroName+"\" stopped because the folder:\n\""+MasterInputDirName+"\"\ndid not contain the required subfolders:\n- \""+RequiredSubfolderArray[ItemI]+"\"";
        UserResponseErrorDialog=ErrorDialog(MessageError, MessageFix, ErrorResponseArray);
        if(UserResponseErrorDialog==ErrorResponseArray[ErrorResponseArray.length-1]){
          CleanExit(MessageQuit);
        } else { // Else user want to select another file
          MasterInputDirPass=0;
          ItemI=RequiredSubfolderArray.length;
        }
      } // end display a message if required subfolder is not found
    } // end for ItemI required subfolders are present

    // if subfolder passed then assess the Content
    if(SubfolderPass==RequiredSubfolderArray.length){
      CroppedInputList=newArray(0);
      ThresholdedInputList=newArray(0);
      // Check for each required subfolder contain at least MinFile with the correct Ext
      for(SubFolderI=0; SubFolderI<RequiredSubfolderArray.length; SubFolderI++){
        ItemInputList=getFileList(MasterInputDirPath+RequiredSubfolderArray[SubFolderI]+File.separator);
        for (ItemI=0; ItemI<ItemInputList.length; ItemI++){
          if(endsWith(toLowerCase(ItemInputList[ItemI]), "."+toLowerCase(FileExt))){ // Select files with correct extension
            BasenameFileIArray=split(ItemInputList[ItemI],"."); // Make an array from the filename
            if(BasenameFileIArray.length!=2){ // if there is more than one . in the file name abort
              MessageError="Sorry but the "+FileExt+" file:\n\""+ItemInputList[ItemI]+"\"\n in the subfolder\n \""+RequiredSubfolderArray[SubFolderI]+"\"contains more than one \".\" in its filename.";
              MessageFix="The function \""+MacroName+"\" does NOT allow filenames with more than one unique \".\" used for the file extension.";
              ErrorResponseArray=newArray("Select Another Folder", "Ignore This File", "Cancel and Close");
              MessageQuit="The function \""+ MacroName+"\" stopped because the file\n\""+RequiredSubfolderArray[SubFolderI]+"\"\ncontains more than one \".\"\nMake sure filenames have no more than one unique \".\" for the file extension.";
              UserResponseErrorDialog=ErrorDialog(MessageError, MessageFix, ErrorResponseArray);
              if(UserResponseErrorDialog==ErrorResponseArray[ErrorResponseArray.length-1]){
                CleanExit(MessageQuit);
              } else if (UserResponseErrorDialog=="Ignore This File"){
                // Ignore
              } else if (UserResponseErrorDialog=="Select Another Folder") {
                ItemI=ItemInputList.length;
                SubFolderI=RequiredSubfolderArray.length; // end the for loop
                MasterInputDirPass=0;
              } // end of response
            } else { // If basename is good add it to the InputList
              if(RequiredSubfolderArray[SubFolderI]=="Cropped"){
                CroppedInputList=Append(CroppedInputList, ItemInputList[ItemI]);
              } else if (RequiredSubfolderArray[SubFolderI]=="Thresholded"){
                ThresholdedInputList=Append(ThresholdedInputList, ItemInputList[ItemI]);
              }
            } // end of else all is good append to the list
          } // end of ends with FileExt
        } // end of for ItemI
      } // end of for SubFolderI

      // If the Nb of File with correct extension is not at least equal to the MinNbFile Create Error Message.
      if(CroppedInputList.length<MinNbFile || ThresholdedInputList.length<MinNbFile ){
        if(CroppedInputList.length<MinNbFile){
          FaultyFolder="Cropped";
        } else if(ThresholdedInputList.length<MinNbFile){
          FaultyFolder="Thresholded";
        }
        MessageError="Sorry but the subfolder:\n\""+FaultyFolder+"\"\nin the folder:\n\""+MasterInputDirName+"\"\ndoes not contain at least "+MinNbFile+" "+FileExt+" file(s).";
        MessageFix="The function \""+MacroName+"\" requires the subfolder\n\""+FaultyFolder+"\"\ncontaining at least "+MinNbFile+" "+FileExt+" file(s).";
        ErrorResponseArray=newArray("Select Another Folder", "Cancel and Close");
        MessageQuit="The function \""+ MacroName+"\" stopped because the subfolder the subfolder\n\""+FaultyFolder+"\"\nin the folder:\n\"" +MasterInputDirName+"\"\ndid not contain at least "+MinNbFile+" "+FileExt+" file(s).";
        UserResponseErrorDialog=ErrorDialog(MessageError, MessageFix, ErrorResponseArray);
        if(UserResponseErrorDialog==ErrorResponseArray[ErrorResponseArray.length-1]){
          CleanExit(MessageQuit);
        } else if(UserResponseErrorDialog=="Select Another Folder") { // Else user want to select another folder
          MasterInputDirPass=0;
        }
      } else {
        // Check file match between subfolders
        FilePass=0;
        InputFileList=newArray(0);
        for (FileI=0; FileI<CroppedInputList.length; FileI++){
          for (FileN=0; FileN<ThresholdedInputList.length; FileN++){
            if(CroppedInputList[FileI]==ThresholdedInputList[FileN]){
              FilePass++;
              FileN=ThresholdedInputList.length;
            }
          } // end for FileN

          if(FilePass!=FileI+1){
            MessageError="Sorry but the file:\n\""+CroppedInputList[FileI]+"\"\nin the subfolder:\n\"Cropped\"\ndoes not have a match in the subfolder:\n\"Thresholded\".";
            MessageFix="The function \""+MacroName+"\" requires the matching files in subfolders.";
            ErrorResponseArray=newArray("Ignore This File", "Select Another Folder", "Cancel and Close");
            MessageQuit="The function \""+ MacroName+"\" stopped because of unmatching file in subfolders.";
            UserResponseErrorDialog=ErrorDialog(MessageError, MessageFix, ErrorResponseArray);
            if(UserResponseErrorDialog==ErrorResponseArray[ErrorResponseArray.length-1]){
              CleanExit(MessageQuit);
            } else if(UserResponseErrorDialog=="Select Another Folder") { // Else user want to select another folder
              FileI=CroppedInputList.length;
              MasterInputDirPass=0;
              FilePass=0;
            }

          } else {
            InputFileList=Append(InputFileList,CroppedInputList[FileI]);

          }
        } // end for FileI

        if(InputFileList.length<MinNbFile){
          MessageError="Sorry but the folder:\n\""+MasterInputDirName+"\"\ndoes not contain subfolders containing at least "+MinNbFile+" matching "+FileExt+" file(s).";
          MessageFix="The function \""+MacroName+"\" requires the subfolders containing at least "+MinNbFile+" matching "+FileExt+" file(s).";
          ErrorResponseArray=newArray("Select Another Folder", "Cancel and Close");
          MessageQuit="The function \""+ MacroName+"\" stopped because the subfolder the subfolder\n\""+FaultyFolder+"\"\nin the folder:\n\"" +MasterInputDirName+"\"\ndid not contain at least "+MinNbFile+" "+FileExt+" file(s).";
          UserResponseErrorDialog=ErrorDialog(MessageError, MessageFix, ErrorResponseArray);
          if(UserResponseErrorDialog==ErrorResponseArray[ErrorResponseArray.length-1]){
            CleanExit(MessageQuit);
          } else if(UserResponseErrorDialog=="Select Another Folder") { // Else user want to select another folder
            MasterInputDirPass=0;
          }
        }else{
          MasterInputDirPass=1;
          NbFile=InputFileList.length;
        }
      }
    } // end of Subfolderpass
  } // end of function
  /////////////////////////// SelectMasterDirectory
  //////////////////////////////////////////////// Specific Functions












  //////////////////////////////////////////////// Macro starts here
  // Intial Message
  InitialMessage="The function \""+MacroName+"\" will:"
  +"\n - Prompt to select a folder containing the following subfolders:";
  for(n=0;n<RequiredSubfolderArray.length; n++){
    InitialMessage=InitialMessage+"\n   - \""+RequiredSubfolderArray[n]+"\"";
  }
  InitialMessage=InitialMessage+"\n    Subfolders must contain at least "+MinNbFile+" matching "+FileExt+" file(s) to process"
  +"\n "
  +"\nFor each "+FileExt+" file:"
  +"\n - Search and track markers"
  +"\n - Prompt user for validation"
  +"\n - Re-analyze the video with adjusted parameters until satisfied"
  +"\n - Save the cleaned videos, labeled videos and the tracked trajectories as TIF files"
  +"\n - Save the result tables as TXT files";

  MessageDialog(InitialMessage); // Display the Initial Message

  // Display a dialog to inform about the requirements
  MessageGetDirectory="You will be prompted to select a folder containing the following subfolder(s):";
  for (n=0; n<RequiredSubfolderArray.length;n++){
    MessageGetDirectory=MessageGetDirectory+"\n- \""+RequiredSubfolderArray[n]+"\"";
  }
  MessageGetDirectory=MessageGetDirectory+"\nSubfolders must contain at least "+MinNbFile+" matching "+FileExt+" file(s) to process.";
  MessageDialog(MessageGetDirectory); // Display the message dialog

  do{
    SelectMasterInputDir(RequiredSubfolderArray, MinNbFile, FileExt);
  }while(MasterInputDirPass!=1)
  // Create OutputDirectory with the Folder suffix
  if(matches(MasterInputDirName,".*_Preprocessed_?[0-9]*")){
    InputDirName=replace(MasterInputDirName,"_Preprocessed_?[0-9]*","");
  } else {
    InputDirName=MasterInputDirName;
  }
  CreateOutputDir(ParentDir, InputDirName, FolderSuffix);

  // Create Output Subdirectory and create general variables for each SubdirectoryOuputdir Path
  CreateOutputSubDir(SubDirArray);

  OutputDirPathTables=""+OutputDirPath+"Tables"+File.separator;
  OutputDirPathLabels=""+OutputDirPath+"Labels"+File.separator;
  OutputDirPathCleaned=""+OutputDirPath+"Cleaned"+File.separator;
  OutputDirPathParameters=""+OutputDirPath+"Parameters"+File.separator;








  //////////////////////////////////////////////// Process each File
  for (FileI = 0; FileI < InputFileList.length; FileI++){
    setBatchMode(true);
    InputFileNameI = InputFileList[FileI];
    BasenameArrayFileI=split(InputFileNameI, ".");
    InputFileNameINoExt=BasenameArrayFileI[0];
    InputFilePathI = MasterInputDirPath+"Thresholded"+File.separator+InputFileNameI;
    open(InputFilePathI);
    rename("Source");
    if(nSlices==1){
      Message="Sorry \""+InputFileNameINoExt+"\" has only one frame."
      +"\nPlease use Analyze>Analyze particles... to detect Markers on still images. "
      +"\n"+PluginNameKinemaJ+" will ignore \""+InputFileNameINoExt+"\" and proceed to the next file.");
      MessageDialog(Message);
      selectWindow("Source");
      close();
    } else if (nSlices>1){
      /////////////////////// Get automatic tracking parameters
      run("Duplicate...", "title=FirstFrame duplicate range=1-1");
      selectWindow("FirstFrame");
      // Set the measurements as area, center of mass and regular Y coordinates
      run("Set Measurements...", "area center redirect=None decimal=9");
      run("Analyze Particles...", "size=1-Infinity show=Nothing clear");
      selectWindow("FirstFrame");
      close();

      // Get the Results
      if(nResults>1){ // If there is any result get the arrays
        AreaArray=newArray(nResults);
        DistanceArray=newArray(nResults-1); // This is the distance between two markers
        for (n=0;n<nResults;n++){
          AreaArray[n]=getResult("Area",n); // This will define the Marker Size
          if (n<nResults-1){ // This calculates the distance between two consecutive detected marker and will estimate the velocity
            DistanceArray[n]=sqrt(pow((getResult("XM",n)-getResult("XM",n+1)),2)+pow((getResult("YM",n)-getResult("YM",n+1)),2));
          }// End of Populate distance array
        } // End of Populate arrays
          run("Clear Results");
        // Get the Statistics of the Arrays
        Array.getStatistics(AreaArray, MinArea, MaxArea, MeanArea, StdDevArea);
        Array.getStatistics(DistanceArray, MinDistance, MaxDistance, MeanDistance, StdDevDistance);
        // Defines the Tracking parameters
        MinMarkerSize=floor(MeanArea*0.25); // Min Marker size should be roughtly a quarter of the mean
        MaxMarkerSize=round(MeanArea*4); // Max Marker size should be roughtly a quarter of the mean
        MaxMarkerVelocity=floor(MeanDistance*0.75); // Using the MaxMarker velocity right below the mean distance between marker to avoid track mixing
        selectWindow("Source");
        getDimensions(ImageWidth, ImageHeight, nbChannels, nbSlices, nbFrames);
        MinTrackLength=floor(nbSlices/9); // why 9? Because ImageJ jump by 10% when clicking on the stack scroll bar
        if(isOpen("Results")){run("Clear Results");selectWindow("Results");run("Close");}
      } else if (!(nResults>1)){ // else if there is no results prompt the user to select manually the parameters
          run("Clear Results");
        DialogPass=0;
        while(DialogPass!=1){
          Dialog.create(PluginName+" Information");
          Dialog.setInsets(0, 0, 0);
          Dialog.addMessage("Sorry but "+MacroName+" could not automatically determine the tracking parameters.");
          Dialog.setInsets(0, 0, 0);
          Dialog.addMessage("Please define manually the tracking parameters:");
          Dialog.addNumber("Min Marker Size", 5, 0, 5, " Pixel^2");
          Dialog.addNumber("Max Marker Size", 500, 0, 5,  " Pixel^2");
          Dialog.addNumber("Max Marker Velocity", 50, 0, 5," Pixel/Frame");
          Dialog.addNumber("Min Track Duration", 5, 0, 6, " Frame");
          Dialog.setInsets(0, 0, 0);
          Dialog.setLocation(ToolbarPosX, ToolbarPosY+ToolbarSizeY+2*Spacer);
          Dialog.show();
          MinMarkerSize=Dialog.getNumber();
          MaxMarkerSize=Dialog.getNumber();
          MaxMarkerVelocity=Dialog.getNumber();
          MinTrackLength=Dialog.getNumber();
          if(isNaN(MinMarkerSize)==1 || MinMarkerSize<0 || isNaN(MaxMarkerSize)==1 || MaxMarkerSize<0 || isNaN(MaxMarkerVelocity)==1 || MaxMarkerVelocity<0 || isNaN(MinTrackLength)==1 || MinTrackLength<=0 || MinTrackLength>nbSlices){
              if(MinTrackLength>nbSlices){
                              MessageError="Sorry but \"Min Track Duration\" must be an integer between 1 and "+nbSlices;
              } else {
                MessageError="Sorry but Tracking Parameters must be positive numbers";
              }
              MessageFix="The function \""+MacroName+"\" requires positive numbers for Tracking Parameters.";
              ErrorResponseArray=newArray("Try Again", "Cancel and Close");
              MessageQuit="The function \""+ MacroName+"\" stopped because Tracking Parameters were not positive numbers.";
              UserResponseErrorDialog=ErrorDialog(MessageError, MessageFix, ErrorResponseArray);
              if(UserResponseErrorDialog==ErrorResponseArray[0]){
                  DialogPass=0;
                } else if (UserResponseErrorDialog==ErrorResponseArray[ErrorResponseArray.length-1]){
                CleanExit(MessageQuit);
              }
            } else { // Else tracking parameters are good
              DialogPass=1;
            } // end of else dialog pass
        } // end of While Dialog is not passed
      } // end of if parameters can't be set automatically

      // Exit batch mode and track the markers
      setBatchMode("exit and display");
      NextStepChoice="Re-Analyze Current File";

      while(NextStepChoice=="Re-Analyze Current File"){
        // REGULAR Y coordinates
      run("Set Measurements...", "redirect=None decimal=9");

        // Set the parameters of Mtrack2
        call("MTrack2_.setProperty","minSize",MinMarkerSize);
        call("MTrack2_.setProperty","maxSize",MaxMarkerSize);
        call("MTrack2_.setProperty","minTrackLength",MinTrackLength);
        call("MTrack2_.setProperty","maxVelocity",MaxMarkerVelocity);
        call("MTrack2_.setProperty","saveResultsFile","false");
        call("MTrack2_.setProperty","showPaths","false");
        call("MTrack2_.setProperty","showPathLengths","false");
        call("MTrack2_.setProperty","showPositions","false");
        call("MTrack2_.setProperty","showLabels","true");
        call("MTrack2_.setProperty","skipDialogue","true");

        selectWindow("Source");
        setLocation(IJPosX,IJPosY+IJSizeY+Spacer,IJSizeX,screenHeight*0.3);
        getLocationAndSize(SourceImagePosX, SourceImagePosY, SourceImageSizeX, SourceImageSizeY);
        run("MTrack2");
        selectWindow("Source"+" labels");
        rename("Tracked");
        setLocation(IJPosX,IJPosY+IJSizeY+Spacer+SourceImageSizeY+Spacer,IJSizeX, screenHeight*0.3);
        getLocationAndSize(TrackedImagePosX,TrackedImagePosY,TrackedImageSizeX,TrackedImageSizeY);

        if(!isOpen("Original")){ // Open the Cropped file if it is not already opened and call it Original
          InputFilePathCropped = MasterInputDirPath+"Cropped"+File.separator+InputFileNameI;
          open(InputFilePathCropped);
          rename("Original");
        }
        selectWindow("Original");
        setLocation(TrackedImagePosX,TrackedImagePosY+TrackedImageSizeY+Spacer,IJSizeX, screenHeight-(TrackedImagePosY+TrackedImageSizeY+Spacer));
        getLocationAndSize(OriginalImagePosX,OriginalImagePosY,OriginalImageSizeX,OriginalImageSizeY);

        if(!isOpen("Synchronize Windows")){
          run("Synchronize Windows");
        }
        selectWindow("Synchronize Windows"); setLocation(OriginalImagePosX+OriginalImageSizeX+Spacer,OriginalImagePosY);

        /////////////////// Wait for User interaction
        setForegroundColor(255, 255, 255); // Foreground is white
        setBackgroundColor(0, 0, 0); // Background is black
        setTool(17); // Select the Bursh
        selectWindow("Source");
        call("ij.gui.WaitForUserDialog.setNextLocation", ToolbarPosX, ToolbarPosY+ToolbarSizeY+2*Spacer);
        waitForUser("KinemaJ Information", ""
        +"- Inspect the Tracked video (middle)"
        +"\n- Correct any missing marker in the Source video (top)"
        +"\n- Use the Original video as reference (bottom)"
        +"\n- Select z-Slices and click Synchronize All to Synchronize the Windows"
        +"\n \nPress OK to Re-Analyze or to Save the Results & Move to the Next File.");


        /////////// Dialog for Move on Next file or Redo Processing

        MessageError="What would you like to do Next?";
        MessageFix="";
        ErrorResponseArray=newArray("Re-Analyze Current File", "Save and Move to Next File");
        NextStepChoice=ErrorDialog(MessageError, MessageFix, ErrorResponseArray);

        /////////////////// If Re-Analyze Display Dialog and Update Tracking parameters
        if(NextStepChoice=="Re-Analyze Current File"){
          DialogPass=0;
          while(DialogPass!=1){
            ProcessingArray=newArray("Reduce Markers", "Amplify Markers", "Remove Noise", "Unmerge Markers");
            ProcessingDefaultArray=newArray(false,false,false,false);
            Dialog.create(PluginName+" Information");
            Dialog.setInsets(0, 0, 0);
            Dialog.addMessage("If necessary select an option below:");
            Dialog.setInsets(0, 0, 0);
            Dialog.addCheckbox("Flip the Video Horizontally", false);
            Dialog.setInsets(0, 0, 0);
            Dialog.addCheckboxGroup(2,2,ProcessingArray,ProcessingDefaultArray);
            Dialog.addMessage("Adjust Tracking parameters:");
            Dialog.addNumber("Min Marker Size (was " + MinMarkerSize+")", MinMarkerSize, 0, 5, " Pixel^2");
            Dialog.addNumber("Max Marker Size (was " + MaxMarkerSize+")", MaxMarkerSize, 0, 5,  " Pixel^2");
            Dialog.addNumber("Max Marker Velocity (was " + MaxMarkerVelocity+")", MaxMarkerVelocity, 0, 5," Pixel/Frame");
            Dialog.addNumber("Min Track duration (was " + MinTrackLength+")", MinTrackLength, 0, 6, " Frame (Max "+nbSlices+")");
  Dialog.setLocation(ToolbarPosX, ToolbarPosY+ToolbarSizeY+2*Spacer);
            Dialog.show();
            FlipChoice=Dialog.getCheckbox();
            ReduceMarkerChoice=Dialog.getCheckbox();
            AmplifyMarkerChoice=Dialog.getCheckbox();
            RemoveNoiseChoice=Dialog.getCheckbox();
            UnmergeMarkerChoice=Dialog.getCheckbox();
            MinMarkerSizeNew=Dialog.getNumber();
            MaxMarkerSizeNew=Dialog.getNumber();
            MaxMarkerVelocityNew=Dialog.getNumber();
            MinTrackLengthNew=Dialog.getNumber();

            if(isNaN(MinMarkerSize)==1 || MinMarkerSize<0 || isNaN(MaxMarkerSize)==1 || MaxMarkerSize<0 || isNaN(MaxMarkerVelocity)==1 || MaxMarkerVelocity<0 || isNaN(MinTrackLength)==1 || MinTrackLength<=0 || MinTrackLength>nbSlices){
                if(MinTrackLength>nbSlices){
                                MessageError="Sorry but \"Min Track Duration\" must be an integer between 1 and "+nbSlices;
                } else {
                  MessageError="Sorry but Tracking Parameters must be positive numbers";
                }
                MessageFix="The function \""+MacroName+"\" requires positive numbers for Tracking Parameters.";
                ErrorResponseArray=newArray("Try Again", "Cancel and Close");
                MessageQuit="The function \""+ MacroName+"\" stopped because Tracking Parameters were not positive numbers.";
                UserResponseErrorDialog=ErrorDialog(MessageError, MessageFix, ErrorResponseArray);
                if(UserResponseErrorDialog==ErrorResponseArray[0]){
                    DialogPass=0;
                  } else if (UserResponseErrorDialog==ErrorResponseArray[ErrorResponseArray.length-1]){
                  CleanExit(MessageQuit);
                }
              } else { // Else tracking parameters are good
                DialogPass=1;
                if(MinMarkerSizeNew>MaxMarkerSizeNew){
                  MaxMarkerSize=MinMarkerSizeNew;
                  MinMarkerSize=MaxMarkerSizeNew;
                }else {
                MinMarkerSize=MinMarkerSizeNew;
                MaxMarkerSize=MaxMarkerSizeNew;
              }
                MaxMarkerVelocity=MaxMarkerVelocityNew;
                MinTrackLength=MinTrackLengthNew;
              } // end of else dialog pass
              } // end of while DialogPass

          selectWindow("Tracked"); // Close the previously tracked version
          close();
          run("Clear Results");


          // Apply the processing options
          if(FlipChoice==1){
            selectWindow("Source");
            run("Flip Horizontally", "stack");
            if(isOpen("Original")){ // Open the Cropped file if it is not already opened and call it Original
              selectWindow("Original");
              run("Flip Horizontally", "stack");
            }
            FlipChoice=0; // Reset the processing option to default
          }

          if(RemoveNoiseChoice==1){
          selectWindow("Source");
            run("Open", "stack");
            RemoveNoiseChoice=0; // Reset the processing option to default
          }

          if(AmplifyMarkerChoice==1){
          selectWindow("Source");
            run("Dilate", "stack");
            AmplifyMarkerChoice=0; // Reset the processing option to default
          }

          if(UnmergeMarkerChoice==1){
            selectWindow("Source");
            run("Watershed", "stack");
            UnmergeMarkerChoice=0; // Reset the processing option to default
          }

          if(ReduceMarkerChoice==1){
          selectWindow("Source");
            run("Erode", "stack");
            ReduceMarkerChoice=0; // Reset the processing option to default
          }
        } /////////////////// If Re-Analyze Display Dialog and Update Tracking parameters
      } //////////////////////////////// End of while loop Next step choice is Re-Analyze

      /////////////////// If Choice is Save and Move to Next File
      if(NextStepChoice=="Save and Move to Next File"){
        selectWindow("Original");
        close();
        selectWindow("Tracked");
        saveAs("Tif", OutputDirPathLabels+InputFileNameINoExt+"_Labels.tif");
        close();
        selectWindow("Source");
        rename(InputFileNameI);
        setBatchMode(true);
        ////////// Re Run the Mtrack2 but saving the data this time in TXT file
        // Create output path name for excel file
        OutputTablePathI=OutputDirPathTables+InputFileNameINoExt+".txt";
        // Invert the Y coordinates
      run("Set Measurements...", "invert redirect=None decimal=9");

        // Set the parameters of Mtrack2
        call("MTrack2_.setProperty","minSize",MinMarkerSize);
        call("MTrack2_.setProperty","maxSize",MaxMarkerSize);
        call("MTrack2_.setProperty","minTrackLength",MinTrackLength);
        call("MTrack2_.setProperty","maxVelocity",MaxMarkerVelocity);
        call("MTrack2_.setProperty","saveResultsFile","true");
        call("MTrack2_.setProperty","showPaths","false");
        call("MTrack2_.setProperty","showPathLengths","false");
        call("MTrack2_.setProperty","showPositions","false");
        call("MTrack2_.setProperty","showLabels","false");
        call("MTrack2_.setProperty","skipDialogue","true");
        run("MTrack2", "save=&OutputTablePathI");
        // Restore the Y coordinates
      run("Set Measurements...", "redirect=None decimal=9");

        run("Clear Results");

        // Save the Cleaned version of the file
        selectWindow(InputFileNameI);
        saveAs("Tif", OutputDirPathCleaned+InputFileNameINoExt+"_Cleaned.tif");
        close();

        // Save the Tracking parameters
        ParametersData = File.open(OutputDirPathParameters+InputFileNameINoExt+"_TrackingParameters.txt");
        CellSeparator= "\t";
        LineSeparator="\n";
        print(ParametersData, "Filename"+CellSeparator+InputFileNameINoExt+LineSeparator);
        print(ParametersData, "Min Marker Size (pixel^2)"+CellSeparator+MinMarkerSize+LineSeparator);
        print(ParametersData, "Max Marker Size (pixel^2)"+CellSeparator+MaxMarkerSize+LineSeparator);
        print(ParametersData, "Max Marker Velocity (pixel/frame)"+CellSeparator+MaxMarkerVelocity+LineSeparator);
        print(ParametersData, "Min Track duration (frame)"+CellSeparator+MinTrackLength+LineSeparator);
        File.close(ParametersData);
      } /////////////////// If Choice is Save and Move to Next File

    } // If nSlices>1

    // Update the progress bar
    showProgress(FileI, InputFileList.length);
    call("java.lang.System.gc"); // Run garbage collector
  }/////////////////////End of for FileI loop

  // Restore the MTack2 dialog box
  call("MTrack2_.setProperty","skipDialogue","false");





  //////////////////////////////////////////////// Closing Dialog
  CloseAndCleanUp(PluginName, FileI, NbFile, FileExt, MasterInputDirName, OutputDirName);
